#!/usr/bin/env node
'use strict';

var _bluebird = require('bluebird');

let execute = (() => {
  var _ref = (0, _bluebird.coroutine)(function* (cmd) {
    let resp = null;
    const conf = yield (0, _utils.getConf)();

    if (!conf.key || !conf.value) {
      console.error('No key/value pair given.');
      process.exit(1);
    }

    const handler = (0, _gitlabCi2.default)(conf.url, conf.token);

    const existingKeys = (yield handler.listVariables()).map(function (variable) {
      return variable.key;
    });

    const keyExists = existingKeys.includes(conf.key);

    if (keyExists && cmd.doNotForce) {
      console.log(`Skipping ${conf.key}, already set.`);
      return undefined;
    }

    if (keyExists) {
      resp = yield handler.updateVariable(conf.key, conf.value);
    } else {
      resp = yield handler.createVariable(conf.key, conf.value);
    }

    console.log('Completed setting variable on Gitlab CI.');
    return resp;
  });

  return function execute(_x) {
    return _ref.apply(this, arguments);
  };
})();

var _commander = require('commander');

var _commander2 = _interopRequireDefault(_commander);

var _utils = require('./lib/utils');

var _gitlabCi = require('./lib/gitlab-ci');

var _gitlabCi2 = _interopRequireDefault(_gitlabCi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_commander2.default.description('Set given key/value pair as environment variables on Gitlab CI').option('--url <url>', 'Your Gitlab project URL, e.g. https://gitlab.com/gitlab-org/gitlab-ce').option('--token <token>', 'Your Gitlab token').option('--key <key>', 'Your Gitlab CI variable').option('--value <value>', 'Your Gitlab CI value').option('--do-not-force', 'Ignore variable if it already exists on gitlab CI. By default variable is overridden').parse(process.argv);

execute(_commander2.default);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9nbGNpLXNldC5qcyJdLCJuYW1lcyI6WyJjbWQiLCJyZXNwIiwiY29uZiIsImtleSIsInZhbHVlIiwiY29uc29sZSIsImVycm9yIiwicHJvY2VzcyIsImV4aXQiLCJoYW5kbGVyIiwidXJsIiwidG9rZW4iLCJleGlzdGluZ0tleXMiLCJsaXN0VmFyaWFibGVzIiwibWFwIiwidmFyaWFibGUiLCJrZXlFeGlzdHMiLCJpbmNsdWRlcyIsImRvTm90Rm9yY2UiLCJsb2ciLCJ1bmRlZmluZWQiLCJ1cGRhdGVWYXJpYWJsZSIsImNyZWF0ZVZhcmlhYmxlIiwiZXhlY3V0ZSIsImRlc2NyaXB0aW9uIiwib3B0aW9uIiwicGFyc2UiLCJhcmd2Il0sIm1hcHBpbmdzIjoiOzs7OztzQ0FNQSxXQUF1QkEsR0FBdkIsRUFBNEI7QUFDMUIsUUFBSUMsT0FBTyxJQUFYO0FBQ0EsVUFBTUMsT0FBTyxNQUFNLHFCQUFuQjs7QUFFQSxRQUFJLENBQUNBLEtBQUtDLEdBQU4sSUFBYSxDQUFDRCxLQUFLRSxLQUF2QixFQUE4QjtBQUM1QkMsY0FBUUMsS0FBUixDQUFjLDBCQUFkO0FBQ0FDLGNBQVFDLElBQVIsQ0FBYSxDQUFiO0FBQ0Q7O0FBRUQsVUFBTUMsVUFBVSx3QkFBU1AsS0FBS1EsR0FBZCxFQUFtQlIsS0FBS1MsS0FBeEIsQ0FBaEI7O0FBRUEsVUFBTUMsZUFBZSxDQUFDLE1BQU1ILFFBQVFJLGFBQVIsRUFBUCxFQUFnQ0MsR0FBaEMsQ0FBb0M7QUFBQSxhQUFZQyxTQUFTWixHQUFyQjtBQUFBLEtBQXBDLENBQXJCOztBQUVBLFVBQU1hLFlBQVlKLGFBQWFLLFFBQWIsQ0FBc0JmLEtBQUtDLEdBQTNCLENBQWxCOztBQUVBLFFBQUlhLGFBQWFoQixJQUFJa0IsVUFBckIsRUFBaUM7QUFDL0JiLGNBQVFjLEdBQVIsQ0FBYSxZQUFXakIsS0FBS0MsR0FBSSxnQkFBakM7QUFDQSxhQUFPaUIsU0FBUDtBQUNEOztBQUVELFFBQUlKLFNBQUosRUFBZTtBQUNiZixhQUFPLE1BQU1RLFFBQVFZLGNBQVIsQ0FBdUJuQixLQUFLQyxHQUE1QixFQUFpQ0QsS0FBS0UsS0FBdEMsQ0FBYjtBQUNELEtBRkQsTUFFTztBQUNMSCxhQUFPLE1BQU1RLFFBQVFhLGNBQVIsQ0FBdUJwQixLQUFLQyxHQUE1QixFQUFpQ0QsS0FBS0UsS0FBdEMsQ0FBYjtBQUNEOztBQUVEQyxZQUFRYyxHQUFSLENBQVksMENBQVo7QUFDQSxXQUFPbEIsSUFBUDtBQUNELEc7O2tCQTVCY3NCLE87Ozs7O0FBSmY7Ozs7QUFDQTs7QUFDQTs7Ozs7O0FBZ0NBLG9CQUNHQyxXQURILENBQ2UsZ0VBRGYsRUFFR0MsTUFGSCxDQUdJLGFBSEosRUFJSSx1RUFKSixFQU1HQSxNQU5ILENBT0ksaUJBUEosRUFRSSxtQkFSSixFQVVHQSxNQVZILENBV0ksYUFYSixFQVlJLHlCQVpKLEVBY0dBLE1BZEgsQ0FlSSxpQkFmSixFQWdCSSxzQkFoQkosRUFrQkdBLE1BbEJILENBbUJJLGdCQW5CSixFQW9CSSxzRkFwQkosRUFzQkdDLEtBdEJILENBc0JTbkIsUUFBUW9CLElBdEJqQjs7QUF3QkFKIiwiZmlsZSI6ImdsY2ktc2V0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5cbmltcG9ydCBwcm9ncmFtIGZyb20gJ2NvbW1hbmRlcic7XG5pbXBvcnQgeyBnZXRDb25mIH0gZnJvbSAnLi9saWIvdXRpbHMnO1xuaW1wb3J0IGdpdGxhYkNJIGZyb20gJy4vbGliL2dpdGxhYi1jaSc7XG5cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGUoY21kKSB7XG4gIGxldCByZXNwID0gbnVsbDtcbiAgY29uc3QgY29uZiA9IGF3YWl0IGdldENvbmYoKTtcblxuICBpZiAoIWNvbmYua2V5IHx8ICFjb25mLnZhbHVlKSB7XG4gICAgY29uc29sZS5lcnJvcignTm8ga2V5L3ZhbHVlIHBhaXIgZ2l2ZW4uJyk7XG4gICAgcHJvY2Vzcy5leGl0KDEpO1xuICB9XG5cbiAgY29uc3QgaGFuZGxlciA9IGdpdGxhYkNJKGNvbmYudXJsLCBjb25mLnRva2VuKTtcblxuICBjb25zdCBleGlzdGluZ0tleXMgPSAoYXdhaXQgaGFuZGxlci5saXN0VmFyaWFibGVzKCkpLm1hcCh2YXJpYWJsZSA9PiB2YXJpYWJsZS5rZXkpO1xuXG4gIGNvbnN0IGtleUV4aXN0cyA9IGV4aXN0aW5nS2V5cy5pbmNsdWRlcyhjb25mLmtleSk7XG5cbiAgaWYgKGtleUV4aXN0cyAmJiBjbWQuZG9Ob3RGb3JjZSkge1xuICAgIGNvbnNvbGUubG9nKGBTa2lwcGluZyAke2NvbmYua2V5fSwgYWxyZWFkeSBzZXQuYCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChrZXlFeGlzdHMpIHtcbiAgICByZXNwID0gYXdhaXQgaGFuZGxlci51cGRhdGVWYXJpYWJsZShjb25mLmtleSwgY29uZi52YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVzcCA9IGF3YWl0IGhhbmRsZXIuY3JlYXRlVmFyaWFibGUoY29uZi5rZXksIGNvbmYudmFsdWUpO1xuICB9XG5cbiAgY29uc29sZS5sb2coJ0NvbXBsZXRlZCBzZXR0aW5nIHZhcmlhYmxlIG9uIEdpdGxhYiBDSS4nKTtcbiAgcmV0dXJuIHJlc3A7XG59XG5cbnByb2dyYW1cbiAgLmRlc2NyaXB0aW9uKCdTZXQgZ2l2ZW4ga2V5L3ZhbHVlIHBhaXIgYXMgZW52aXJvbm1lbnQgdmFyaWFibGVzIG9uIEdpdGxhYiBDSScpXG4gIC5vcHRpb24oXG4gICAgJy0tdXJsIDx1cmw+JyxcbiAgICAnWW91ciBHaXRsYWIgcHJvamVjdCBVUkwsIGUuZy4gaHR0cHM6Ly9naXRsYWIuY29tL2dpdGxhYi1vcmcvZ2l0bGFiLWNlJyxcbiAgKVxuICAub3B0aW9uKFxuICAgICctLXRva2VuIDx0b2tlbj4nLFxuICAgICdZb3VyIEdpdGxhYiB0b2tlbicsXG4gIClcbiAgLm9wdGlvbihcbiAgICAnLS1rZXkgPGtleT4nLFxuICAgICdZb3VyIEdpdGxhYiBDSSB2YXJpYWJsZScsXG4gIClcbiAgLm9wdGlvbihcbiAgICAnLS12YWx1ZSA8dmFsdWU+JyxcbiAgICAnWW91ciBHaXRsYWIgQ0kgdmFsdWUnLFxuICApXG4gIC5vcHRpb24oXG4gICAgJy0tZG8tbm90LWZvcmNlJyxcbiAgICAnSWdub3JlIHZhcmlhYmxlIGlmIGl0IGFscmVhZHkgZXhpc3RzIG9uIGdpdGxhYiBDSS4gQnkgZGVmYXVsdCB2YXJpYWJsZSBpcyBvdmVycmlkZGVuJyxcbiAgKVxuICAucGFyc2UocHJvY2Vzcy5hcmd2KTtcblxuZXhlY3V0ZShwcm9ncmFtKTtcbiJdfQ==